package mockery

import (
	"bufio"
	"fmt"
	"go/format"
	"io/ioutil"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

const pkg = "test"

type GeneratorSuite struct {
	suite.Suite
	parser *Parser
}

func (s *GeneratorSuite) SetupTest() {
	s.parser = NewParser(nil)
}

func (s *GeneratorSuite) getInterfaceFromFile(interfacePath, interfaceName string) *Interface {
	if !strings.Contains(interfacePath, fixturePath) {
		interfacePath = filepath.Join(fixturePath, interfacePath)
	}
	s.NoError(
		s.parser.Parse(interfacePath), "The parser is able to parse the given file.",
	)

	s.NoError(
		s.parser.Load(), "The parser is able to load the config.",
	)

	iface, err := s.parser.Find(interfaceName)
	s.Require().NoError(err)
	s.Require().NotNil(iface)
	return iface
}

func (s *GeneratorSuite) getGenerator(
	filepath, interfaceName string, inPackage bool,
) *Generator {
	return NewGenerator(s.getInterfaceFromFile(filepath, interfaceName), pkg, inPackage)
}

func (s *GeneratorSuite) checkGeneration(
	filepath, interfaceName string, inPackage bool, expected string,
) *Generator {
	generator := s.getGenerator(filepath, interfaceName, inPackage)
	s.NoError(generator.Generate(), "The generator ran without errors.")

	// Mirror the formatting done by normally done by golang.org/x/tools/imports in Generator.Write.
	//
	// While we could possibly reuse Generator.Write here in addition to Generator.Generate,
	// it would require changing Write's signature to accept custom options, specifically to
	// allow the fragments in preexisting cases. It's assumed that this approximation,
	// just formatting the source, is sufficient for the needs of the current test styles.
	var actual []byte
	actual, fmtErr := format.Source(generator.buf.Bytes())
	s.NoError(fmtErr, "The formatter ran without errors.")

	// Compare lines for easier debugging via testify's slice diff output
	expectedLines := strings.Split(expected, "\n")
	actualLines := strings.Split(string(actual), "\n")

	s.Equal(
		expectedLines, actualLines,
		"The generator produced the expected output.",
	)
	return generator
}

func (s *GeneratorSuite) checkPrologueGeneration(
	generator *Generator, expected string,
) {
	generator.GeneratePrologue("mocks")
	s.Equal(
		expected, generator.buf.String(),
		"The generator produced the expected prologue.",
	)
}

func (s *GeneratorSuite) TestCalculateImport() {
	gp := []string{"a/src", "b/src"}

	s.Equal("c", calculateImport(gp, "a/src/c"))
	s.Equal("c", calculateImport(gp, "b/src/c"))
	s.Equal("d/src/c", calculateImport(gp, "d/src/c"))
}

func (s *GeneratorSuite) TestGenerator() {
	expected := `// Requester is an autogenerated mock type for the Requester type
type Requester struct {
	mock.Mock
}

type RequesterExpectation struct {
	mock *mock.Mock
}

func (_m *Requester) Expect() *RequesterExpectation {
	return &RequesterExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: path
func (_m *Requester) Get(path string) (string, error) {
	ret := _m.Called(path)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type RequesterGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterExpectation) Get(path string) *RequesterGetExpectation {
	return &RequesterGetExpectation{
		call: _e.mock.On("Get", path),
	}
}

func (_e *RequesterGetExpectation) ToReturn(_a0 string, _a1 error) *mock.Call {
	return _e.call.Return(_a0, _a1)
}
`
	s.checkGeneration(testFile, "Requester", false, expected)
}

func (s *GeneratorSuite) TestGeneratorSingleReturn() {
	expected := `// Requester2 is an autogenerated mock type for the Requester2 type
type Requester2 struct {
	mock.Mock
}

type Requester2Expectation struct {
	mock *mock.Mock
}

func (_m *Requester2) Expect() *Requester2Expectation {
	return &Requester2Expectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: path
func (_m *Requester2) Get(path string) error {
	ret := _m.Called(path)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type Requester2GetExpectation struct {
	call *mock.Call
}

func (_e *Requester2Expectation) Get(path string) *Requester2GetExpectation {
	return &Requester2GetExpectation{
		call: _e.mock.On("Get", path),
	}
}

func (_e *Requester2GetExpectation) ToReturn(_a0 error) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(testFile2, "Requester2", false, expected)
}

func (s *GeneratorSuite) TestGeneratorNoArguments() {
	expected := `// Requester3 is an autogenerated mock type for the Requester3 type
type Requester3 struct {
	mock.Mock
}

type Requester3Expectation struct {
	mock *mock.Mock
}

func (_m *Requester3) Expect() *Requester3Expectation {
	return &Requester3Expectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields:
func (_m *Requester3) Get() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type Requester3GetExpectation struct {
	call *mock.Call
}

func (_e *Requester3Expectation) Get() *Requester3GetExpectation {
	return &Requester3GetExpectation{
		call: _e.mock.On("Get"),
	}
}

func (_e *Requester3GetExpectation) ToReturn(_a0 error) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester3.go"), "Requester3", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorNoNothing() {
	expected := `// Requester4 is an autogenerated mock type for the Requester4 type
type Requester4 struct {
	mock.Mock
}

type Requester4Expectation struct {
	mock *mock.Mock
}

func (_m *Requester4) Expect() *Requester4Expectation {
	return &Requester4Expectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields:
func (_m *Requester4) Get() {
	_m.Called()
}

type Requester4GetExpectation struct {
	call *mock.Call
}

func (_e *Requester4Expectation) Get() *Requester4GetExpectation {
	return &Requester4GetExpectation{
		call: _e.mock.On("Get"),
	}
}

func (_e *Requester4GetExpectation) ToReturn() *mock.Call {
	return _e.call.Return()
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester4.go"), "Requester4", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorUnexported() {
	expected := `// mockRequester_unexported is an autogenerated mock type for the requester_unexported type
type mockRequester_unexported struct {
	mock.Mock
}

type mockRequester_unexportedExpectation struct {
	mock *mock.Mock
}

func (_m *mockRequester_unexported) Expect() *mockRequester_unexportedExpectation {
	return &mockRequester_unexportedExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields:
func (_m *mockRequester_unexported) Get() {
	_m.Called()
}

type mockRequester_unexportedGetExpectation struct {
	call *mock.Call
}

func (_e *mockRequester_unexportedExpectation) Get() *mockRequester_unexportedGetExpectation {
	return &mockRequester_unexportedGetExpectation{
		call: _e.mock.On("Get"),
	}
}

func (_e *mockRequester_unexportedGetExpectation) ToReturn() *mock.Call {
	return _e.call.Return()
}
`
	s.checkGeneration(
		"requester_unexported.go", "requester_unexported", true, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorPrologue() {
	generator := s.getGenerator(testFile, "Requester", false)
	expected := `package mocks

import mock "github.com/stretchr/testify/mock"
import test "github.com/namely/mockery/mockery/fixtures"

`
	s.checkPrologueGeneration(generator, expected)
}

func (s *GeneratorSuite) TestGeneratorPrologueWithImports() {
	generator := s.getGenerator("requester_ns.go", "RequesterNS", false)
	expected := `package mocks

import http "net/http"
import mock "github.com/stretchr/testify/mock"
import test "github.com/namely/mockery/mockery/fixtures"

`
	s.checkPrologueGeneration(generator, expected)
}

func (s *GeneratorSuite) TestGeneratorPrologueWithMultipleImportsSameName() {
	generator := s.getGenerator("same_name_imports.go", "Example", false)

	expected := `package mocks

import fixtureshttp "github.com/namely/mockery/mockery/fixtures/http"
import http "net/http"
import mock "github.com/stretchr/testify/mock"
import test "github.com/namely/mockery/mockery/fixtures"

`
	s.checkPrologueGeneration(generator, expected)
}

func (s *GeneratorSuite) TestGeneratorPrologueNote() {
	generator := s.getGenerator(testFile, "Requester", false)
	generator.GeneratePrologueNote("A\\nB")

	expected := fmt.Sprintf(`// Code generated by mockery v%s. DO NOT EDIT.

// A
// B

`, SemVer)

	s.Equal(expected, generator.buf.String())
}

func (s *GeneratorSuite) TestVersionOnCorrectLine() {
	gen := s.getGenerator(testFile, "Requester", false)

	// Run everything that is ran by the GeneratorVisitor
	gen.GeneratePrologueNote("A\\nB")
	gen.GeneratePrologue(pkg)
	err := gen.Generate()

	require.NoError(s.T(), err)
	scan := bufio.NewScanner(&gen.buf)
	s.Contains("Code generated by", scan.Text())
}

func (s *GeneratorSuite) TestGeneratorChecksInterfacesForNilable() {
	expected := `// RequesterIface is an autogenerated mock type for the RequesterIface type
type RequesterIface struct {
	mock.Mock
}

type RequesterIfaceExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterIface) Expect() *RequesterIfaceExpectation {
	return &RequesterIfaceExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields:
func (_m *RequesterIface) Get() io.Reader {
	ret := _m.Called()

	var r0 io.Reader
	if rf, ok := ret.Get(0).(func() io.Reader); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Reader)
		}
	}

	return r0
}

type RequesterIfaceGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterIfaceExpectation) Get() *RequesterIfaceGetExpectation {
	return &RequesterIfaceGetExpectation{
		call: _e.mock.On("Get"),
	}
}

func (_e *RequesterIfaceGetExpectation) ToReturn(_a0 io.Reader) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_iface.go"), "RequesterIface",
		false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorPointers() {
	expected := `// RequesterPtr is an autogenerated mock type for the RequesterPtr type
type RequesterPtr struct {
	mock.Mock
}

type RequesterPtrExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterPtr) Expect() *RequesterPtrExpectation {
	return &RequesterPtrExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: path
func (_m *RequesterPtr) Get(path string) (*string, error) {
	ret := _m.Called(path)

	var r0 *string
	if rf, ok := ret.Get(0).(func(string) *string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type RequesterPtrGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterPtrExpectation) Get(path string) *RequesterPtrGetExpectation {
	return &RequesterPtrGetExpectation{
		call: _e.mock.On("Get", path),
	}
}

func (_e *RequesterPtrGetExpectation) ToReturn(_a0 *string, _a1 error) *mock.Call {
	return _e.call.Return(_a0, _a1)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_ptr.go"), "RequesterPtr", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorSlice() {
	expected := `// RequesterSlice is an autogenerated mock type for the RequesterSlice type
type RequesterSlice struct {
	mock.Mock
}

type RequesterSliceExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterSlice) Expect() *RequesterSliceExpectation {
	return &RequesterSliceExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: path
func (_m *RequesterSlice) Get(path string) ([]string, error) {
	ret := _m.Called(path)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type RequesterSliceGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterSliceExpectation) Get(path string) *RequesterSliceGetExpectation {
	return &RequesterSliceGetExpectation{
		call: _e.mock.On("Get", path),
	}
}

func (_e *RequesterSliceGetExpectation) ToReturn(_a0 []string, _a1 error) *mock.Call {
	return _e.call.Return(_a0, _a1)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_slice.go"), "RequesterSlice",
		false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorArrayLiteralLen() {
	expected := `// RequesterArray is an autogenerated mock type for the RequesterArray type
type RequesterArray struct {
	mock.Mock
}

type RequesterArrayExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterArray) Expect() *RequesterArrayExpectation {
	return &RequesterArrayExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: path
func (_m *RequesterArray) Get(path string) ([2]string, error) {
	ret := _m.Called(path)

	var r0 [2]string
	if rf, ok := ret.Get(0).(func(string) [2]string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([2]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type RequesterArrayGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterArrayExpectation) Get(path string) *RequesterArrayGetExpectation {
	return &RequesterArrayGetExpectation{
		call: _e.mock.On("Get", path),
	}
}

func (_e *RequesterArrayGetExpectation) ToReturn(_a0 [2]string, _a1 error) *mock.Call {
	return _e.call.Return(_a0, _a1)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_array.go"), "RequesterArray",
		false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorNamespacedTypes() {
	expected := `// RequesterNS is an autogenerated mock type for the RequesterNS type
type RequesterNS struct {
	mock.Mock
}

type RequesterNSExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterNS) Expect() *RequesterNSExpectation {
	return &RequesterNSExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: path
func (_m *RequesterNS) Get(path string) (http.Response, error) {
	ret := _m.Called(path)

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(string) http.Response); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(http.Response)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type RequesterNSGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterNSExpectation) Get(path string) *RequesterNSGetExpectation {
	return &RequesterNSGetExpectation{
		call: _e.mock.On("Get", path),
	}
}

func (_e *RequesterNSGetExpectation) ToReturn(_a0 http.Response, _a1 error) *mock.Call {
	return _e.call.Return(_a0, _a1)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_ns.go"), "RequesterNS", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorWhereArgumentNameConflictsWithImport() {
	expected := `// RequesterArgSameAsImport is an autogenerated mock type for the RequesterArgSameAsImport type
type RequesterArgSameAsImport struct {
	mock.Mock
}

type RequesterArgSameAsImportExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterArgSameAsImport) Expect() *RequesterArgSameAsImportExpectation {
	return &RequesterArgSameAsImportExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: _a0
func (_m *RequesterArgSameAsImport) Get(_a0 string) *json.RawMessage {
	ret := _m.Called(_a0)

	var r0 *json.RawMessage
	if rf, ok := ret.Get(0).(func(string) *json.RawMessage); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*json.RawMessage)
		}
	}

	return r0
}

type RequesterArgSameAsImportGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterArgSameAsImportExpectation) Get(_a0 string) *RequesterArgSameAsImportGetExpectation {
	return &RequesterArgSameAsImportGetExpectation{
		call: _e.mock.On("Get", _a0),
	}
}

func (_e *RequesterArgSameAsImportGetExpectation) ToReturn(_a0 *json.RawMessage) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_arg_same_as_import.go"),
		"RequesterArgSameAsImport", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorWhereArgumentNameConflictsWithNamedImport() {
	expected := `// RequesterArgSameAsNamedImport is an autogenerated mock type for the RequesterArgSameAsNamedImport type
type RequesterArgSameAsNamedImport struct {
	mock.Mock
}

type RequesterArgSameAsNamedImportExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterArgSameAsNamedImport) Expect() *RequesterArgSameAsNamedImportExpectation {
	return &RequesterArgSameAsNamedImportExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: _a0
func (_m *RequesterArgSameAsNamedImport) Get(_a0 string) *json.RawMessage {
	ret := _m.Called(_a0)

	var r0 *json.RawMessage
	if rf, ok := ret.Get(0).(func(string) *json.RawMessage); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*json.RawMessage)
		}
	}

	return r0
}

type RequesterArgSameAsNamedImportGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterArgSameAsNamedImportExpectation) Get(_a0 string) *RequesterArgSameAsNamedImportGetExpectation {
	return &RequesterArgSameAsNamedImportGetExpectation{
		call: _e.mock.On("Get", _a0),
	}
}

func (_e *RequesterArgSameAsNamedImportGetExpectation) ToReturn(_a0 *json.RawMessage) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_arg_same_as_named_import.go"),
		"RequesterArgSameAsNamedImport", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorWhereArgumentNameConflictsWithPackage() {
	expected := `// RequesterArgSameAsPkg is an autogenerated mock type for the RequesterArgSameAsPkg type
type RequesterArgSameAsPkg struct {
	mock.Mock
}

type RequesterArgSameAsPkgExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterArgSameAsPkg) Expect() *RequesterArgSameAsPkgExpectation {
	return &RequesterArgSameAsPkgExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: _a0
func (_m *RequesterArgSameAsPkg) Get(_a0 string) {
	_m.Called(_a0)
}

type RequesterArgSameAsPkgGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterArgSameAsPkgExpectation) Get(_a0 string) *RequesterArgSameAsPkgGetExpectation {
	return &RequesterArgSameAsPkgGetExpectation{
		call: _e.mock.On("Get", _a0),
	}
}

func (_e *RequesterArgSameAsPkgGetExpectation) ToReturn() *mock.Call {
	return _e.call.Return()
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_arg_same_as_pkg.go"),
		"RequesterArgSameAsPkg", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorHavingNoNamesOnArguments() {
	expected := `// KeyManager is an autogenerated mock type for the KeyManager type
type KeyManager struct {
	mock.Mock
}

type KeyManagerExpectation struct {
	mock *mock.Mock
}

func (_m *KeyManager) Expect() *KeyManagerExpectation {
	return &KeyManagerExpectation{mock: &_m.Mock}
}

// GetKey provides a mock function with given fields: _a0, _a1
func (_m *KeyManager) GetKey(_a0 string, _a1 uint16) ([]byte, *test.Err) {
	ret := _m.Called(_a0, _a1)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string, uint16) []byte); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 *test.Err
	if rf, ok := ret.Get(1).(func(string, uint16) *test.Err); ok {
		r1 = rf(_a0, _a1)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*test.Err)
		}
	}

	return r0, r1
}

type KeyManagerGetKeyExpectation struct {
	call *mock.Call
}

func (_e *KeyManagerExpectation) GetKey(_a0 string, _a1 uint16) *KeyManagerGetKeyExpectation {
	return &KeyManagerGetKeyExpectation{
		call: _e.mock.On("GetKey", _a0, _a1),
	}
}

func (_e *KeyManagerGetKeyExpectation) ToReturn(_a0 []byte, _a1 *test.Err) *mock.Call {
	return _e.call.Return(_a0, _a1)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "custom_error.go"), "KeyManager", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorElidedType() {
	expected := `// RequesterElided is an autogenerated mock type for the RequesterElided type
type RequesterElided struct {
	mock.Mock
}

type RequesterElidedExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterElided) Expect() *RequesterElidedExpectation {
	return &RequesterElidedExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: path, url
func (_m *RequesterElided) Get(path string, url string) error {
	ret := _m.Called(path, url)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(path, url)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type RequesterElidedGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterElidedExpectation) Get(path string, url string) *RequesterElidedGetExpectation {
	return &RequesterElidedGetExpectation{
		call: _e.mock.On("Get", path, url),
	}
}

func (_e *RequesterElidedGetExpectation) ToReturn(_a0 error) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_elided.go"), "RequesterElided",
		false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorReturnElidedType() {
	expected := `// RequesterReturnElided is an autogenerated mock type for the RequesterReturnElided type
type RequesterReturnElided struct {
	mock.Mock
}

type RequesterReturnElidedExpectation struct {
	mock *mock.Mock
}

func (_m *RequesterReturnElided) Expect() *RequesterReturnElidedExpectation {
	return &RequesterReturnElidedExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: path
func (_m *RequesterReturnElided) Get(path string) (int, int, int, error) {
	ret := _m.Called(path)

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string) int); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 int
	if rf, ok := ret.Get(2).(func(string) int); ok {
		r2 = rf(path)
	} else {
		r2 = ret.Get(2).(int)
	}

	var r3 error
	if rf, ok := ret.Get(3).(func(string) error); ok {
		r3 = rf(path)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

type RequesterReturnElidedGetExpectation struct {
	call *mock.Call
}

func (_e *RequesterReturnElidedExpectation) Get(path string) *RequesterReturnElidedGetExpectation {
	return &RequesterReturnElidedGetExpectation{
		call: _e.mock.On("Get", path),
	}
}

func (_e *RequesterReturnElidedGetExpectation) ToReturn(a int, b int, c int, err error) *mock.Call {
	return _e.call.Return(a, b, c, err)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_ret_elided.go"),
		"RequesterReturnElided", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorVariadicArgs() {
	// Read the expected output from a "golden" file that we can also import in CompatSuite
	// to asserts its actual behavior.
	//
	// To regenerate the golden file: make fixture
	expectedBytes, err := ioutil.ReadFile(filepath.Join(fixturePath, "mocks", "requester_variadic.go"))
	s.NoError(err)
	expected := string(expectedBytes)
	expected = expected[strings.Index(expected, "// RequesterVariadic is"):]
	s.checkGeneration(
		filepath.Join(fixturePath, "requester_variadic.go"),
		"RequesterVariadic", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorFuncType() {
	expected := `// Fooer is an autogenerated mock type for the Fooer type
type Fooer struct {
	mock.Mock
}

type FooerExpectation struct {
	mock *mock.Mock
}

func (_m *Fooer) Expect() *FooerExpectation {
	return &FooerExpectation{mock: &_m.Mock}
}

// Bar provides a mock function with given fields: f
func (_m *Fooer) Bar(f func([]int)) {
	_m.Called(f)
}

type FooerBarExpectation struct {
	call *mock.Call
}

func (_e *FooerExpectation) Bar(f func([]int)) *FooerBarExpectation {
	return &FooerBarExpectation{
		call: _e.mock.On("Bar", f),
	}
}

func (_e *FooerBarExpectation) ToReturn() *mock.Call {
	return _e.call.Return()
}

// Baz provides a mock function with given fields: path
func (_m *Fooer) Baz(path string) func(string) string {
	ret := _m.Called(path)

	var r0 func(string) string
	if rf, ok := ret.Get(0).(func(string) func(string) string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func(string) string)
		}
	}

	return r0
}

type FooerBazExpectation struct {
	call *mock.Call
}

func (_e *FooerExpectation) Baz(path string) *FooerBazExpectation {
	return &FooerBazExpectation{
		call: _e.mock.On("Baz", path),
	}
}

func (_e *FooerBazExpectation) ToReturn(_a0 func(string) string) *mock.Call {
	return _e.call.Return(_a0)
}

// Foo provides a mock function with given fields: f
func (_m *Fooer) Foo(f func(string) string) error {
	ret := _m.Called(f)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(string) string) error); ok {
		r0 = rf(f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type FooerFooExpectation struct {
	call *mock.Call
}

func (_e *FooerExpectation) Foo(f func(string) string) *FooerFooExpectation {
	return &FooerFooExpectation{
		call: _e.mock.On("Foo", f),
	}
}

func (_e *FooerFooExpectation) ToReturn(_a0 error) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "func_type.go"), "Fooer", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorChanType() {
	expected := `// AsyncProducer is an autogenerated mock type for the AsyncProducer type
type AsyncProducer struct {
	mock.Mock
}

type AsyncProducerExpectation struct {
	mock *mock.Mock
}

func (_m *AsyncProducer) Expect() *AsyncProducerExpectation {
	return &AsyncProducerExpectation{mock: &_m.Mock}
}

// Input provides a mock function with given fields:
func (_m *AsyncProducer) Input() chan<- bool {
	ret := _m.Called()

	var r0 chan<- bool
	if rf, ok := ret.Get(0).(func() chan<- bool); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan<- bool)
		}
	}

	return r0
}

type AsyncProducerInputExpectation struct {
	call *mock.Call
}

func (_e *AsyncProducerExpectation) Input() *AsyncProducerInputExpectation {
	return &AsyncProducerInputExpectation{
		call: _e.mock.On("Input"),
	}
}

func (_e *AsyncProducerInputExpectation) ToReturn(_a0 chan<- bool) *mock.Call {
	return _e.call.Return(_a0)
}

// Output provides a mock function with given fields:
func (_m *AsyncProducer) Output() <-chan bool {
	ret := _m.Called()

	var r0 <-chan bool
	if rf, ok := ret.Get(0).(func() <-chan bool); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan bool)
		}
	}

	return r0
}

type AsyncProducerOutputExpectation struct {
	call *mock.Call
}

func (_e *AsyncProducerExpectation) Output() *AsyncProducerOutputExpectation {
	return &AsyncProducerOutputExpectation{
		call: _e.mock.On("Output"),
	}
}

func (_e *AsyncProducerOutputExpectation) ToReturn(_a0 <-chan bool) *mock.Call {
	return _e.call.Return(_a0)
}

// Whatever provides a mock function with given fields:
func (_m *AsyncProducer) Whatever() chan bool {
	ret := _m.Called()

	var r0 chan bool
	if rf, ok := ret.Get(0).(func() chan bool); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan bool)
		}
	}

	return r0
}

type AsyncProducerWhateverExpectation struct {
	call *mock.Call
}

func (_e *AsyncProducerExpectation) Whatever() *AsyncProducerWhateverExpectation {
	return &AsyncProducerWhateverExpectation{
		call: _e.mock.On("Whatever"),
	}
}

func (_e *AsyncProducerWhateverExpectation) ToReturn(_a0 chan bool) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "async.go"), "AsyncProducer", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorFromImport() {
	expected := `// MyReader is an autogenerated mock type for the MyReader type
type MyReader struct {
	mock.Mock
}

type MyReaderExpectation struct {
	mock *mock.Mock
}

func (_m *MyReader) Expect() *MyReaderExpectation {
	return &MyReaderExpectation{mock: &_m.Mock}
}

// Read provides a mock function with given fields: p
func (_m *MyReader) Read(p []byte) (int, error) {
	ret := _m.Called(p)

	var r0 int
	if rf, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type MyReaderReadExpectation struct {
	call *mock.Call
}

func (_e *MyReaderExpectation) Read(p []byte) *MyReaderReadExpectation {
	return &MyReaderReadExpectation{
		call: _e.mock.On("Read", p),
	}
}

func (_e *MyReaderReadExpectation) ToReturn(n int, err error) *mock.Call {
	return _e.call.Return(n, err)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "io_import.go"), "MyReader", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorComplexChanFromConsul() {
	expected := `// ConsulLock is an autogenerated mock type for the ConsulLock type
type ConsulLock struct {
	mock.Mock
}

type ConsulLockExpectation struct {
	mock *mock.Mock
}

func (_m *ConsulLock) Expect() *ConsulLockExpectation {
	return &ConsulLockExpectation{mock: &_m.Mock}
}

// Lock provides a mock function with given fields: _a0
func (_m *ConsulLock) Lock(_a0 <-chan struct{}) (<-chan struct{}, error) {
	ret := _m.Called(_a0)

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func(<-chan struct{}) <-chan struct{}); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(<-chan struct{}) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ConsulLockLockExpectation struct {
	call *mock.Call
}

func (_e *ConsulLockExpectation) Lock(_a0 <-chan struct{}) *ConsulLockLockExpectation {
	return &ConsulLockLockExpectation{
		call: _e.mock.On("Lock", _a0),
	}
}

func (_e *ConsulLockLockExpectation) ToReturn(_a0 <-chan struct{}, _a1 error) *mock.Call {
	return _e.call.Return(_a0, _a1)
}

// Unlock provides a mock function with given fields:
func (_m *ConsulLock) Unlock() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type ConsulLockUnlockExpectation struct {
	call *mock.Call
}

func (_e *ConsulLockExpectation) Unlock() *ConsulLockUnlockExpectation {
	return &ConsulLockUnlockExpectation{
		call: _e.mock.On("Unlock"),
	}
}

func (_e *ConsulLockUnlockExpectation) ToReturn(_a0 error) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "consul.go"), "ConsulLock", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorForEmptyInterface() {
	expected := `// Blank is an autogenerated mock type for the Blank type
type Blank struct {
	mock.Mock
}

type BlankExpectation struct {
	mock *mock.Mock
}

func (_m *Blank) Expect() *BlankExpectation {
	return &BlankExpectation{mock: &_m.Mock}
}

// Create provides a mock function with given fields: x
func (_m *Blank) Create(x interface{}) error {
	ret := _m.Called(x)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(x)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type BlankCreateExpectation struct {
	call *mock.Call
}

func (_e *BlankExpectation) Create(x interface{}) *BlankCreateExpectation {
	return &BlankCreateExpectation{
		call: _e.mock.On("Create", x),
	}
}

func (_e *BlankCreateExpectation) ToReturn(_a0 error) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "empty_interface.go"), "Blank", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorForMapFunc() {
	expected := `// MapFunc is an autogenerated mock type for the MapFunc type
type MapFunc struct {
	mock.Mock
}

type MapFuncExpectation struct {
	mock *mock.Mock
}

func (_m *MapFunc) Expect() *MapFuncExpectation {
	return &MapFuncExpectation{mock: &_m.Mock}
}

// Get provides a mock function with given fields: m
func (_m *MapFunc) Get(m map[string]func(string) string) error {
	ret := _m.Called(m)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]func(string) string) error); ok {
		r0 = rf(m)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type MapFuncGetExpectation struct {
	call *mock.Call
}

func (_e *MapFuncExpectation) Get(m map[string]func(string) string) *MapFuncGetExpectation {
	return &MapFuncGetExpectation{
		call: _e.mock.On("Get", m),
	}
}

func (_e *MapFuncGetExpectation) ToReturn(_a0 error) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "map_func.go"), "MapFunc", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorForMethodUsingInterface() {
	expected := `// UsesOtherPkgIface is an autogenerated mock type for the UsesOtherPkgIface type
type UsesOtherPkgIface struct {
	mock.Mock
}

type UsesOtherPkgIfaceExpectation struct {
	mock *mock.Mock
}

func (_m *UsesOtherPkgIface) Expect() *UsesOtherPkgIfaceExpectation {
	return &UsesOtherPkgIfaceExpectation{mock: &_m.Mock}
}

// DoSomethingElse provides a mock function with given fields: obj
func (_m *UsesOtherPkgIface) DoSomethingElse(obj test.Sibling) {
	_m.Called(obj)
}

type UsesOtherPkgIfaceDoSomethingElseExpectation struct {
	call *mock.Call
}

func (_e *UsesOtherPkgIfaceExpectation) DoSomethingElse(obj test.Sibling) *UsesOtherPkgIfaceDoSomethingElseExpectation {
	return &UsesOtherPkgIfaceDoSomethingElseExpectation{
		call: _e.mock.On("DoSomethingElse", obj),
	}
}

func (_e *UsesOtherPkgIfaceDoSomethingElseExpectation) ToReturn() *mock.Call {
	return _e.call.Return()
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "mock_method_uses_pkg_iface.go"),
		"UsesOtherPkgIface", false, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorForMethodUsingInterfaceInPackage() {
	expected := `// MockUsesOtherPkgIface is an autogenerated mock type for the UsesOtherPkgIface type
type MockUsesOtherPkgIface struct {
	mock.Mock
}

type MockUsesOtherPkgIfaceExpectation struct {
	mock *mock.Mock
}

func (_m *MockUsesOtherPkgIface) Expect() *MockUsesOtherPkgIfaceExpectation {
	return &MockUsesOtherPkgIfaceExpectation{mock: &_m.Mock}
}

// DoSomethingElse provides a mock function with given fields: obj
func (_m *MockUsesOtherPkgIface) DoSomethingElse(obj Sibling) {
	_m.Called(obj)
}

type MockUsesOtherPkgIfaceDoSomethingElseExpectation struct {
	call *mock.Call
}

func (_e *MockUsesOtherPkgIfaceExpectation) DoSomethingElse(obj Sibling) *MockUsesOtherPkgIfaceDoSomethingElseExpectation {
	return &MockUsesOtherPkgIfaceDoSomethingElseExpectation{
		call: _e.mock.On("DoSomethingElse", obj),
	}
}

func (_e *MockUsesOtherPkgIfaceDoSomethingElseExpectation) ToReturn() *mock.Call {
	return _e.call.Return()
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "mock_method_uses_pkg_iface.go"),
		"UsesOtherPkgIface", true, expected,
	)
}

func (s *GeneratorSuite) TestGeneratorWithAliasing() {
	expected := `// Example is an autogenerated mock type for the Example type
type Example struct {
	mock.Mock
}

type ExampleExpectation struct {
	mock *mock.Mock
}

func (_m *Example) Expect() *ExampleExpectation {
	return &ExampleExpectation{mock: &_m.Mock}
}

// A provides a mock function with given fields:
func (_m *Example) A() http.Flusher {
	ret := _m.Called()

	var r0 http.Flusher
	if rf, ok := ret.Get(0).(func() http.Flusher); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Flusher)
		}
	}

	return r0
}

type ExampleAExpectation struct {
	call *mock.Call
}

func (_e *ExampleExpectation) A() *ExampleAExpectation {
	return &ExampleAExpectation{
		call: _e.mock.On("A"),
	}
}

func (_e *ExampleAExpectation) ToReturn(_a0 http.Flusher) *mock.Call {
	return _e.call.Return(_a0)
}

// B provides a mock function with given fields: _a0
func (_m *Example) B(_a0 string) fixtureshttp.MyStruct {
	ret := _m.Called(_a0)

	var r0 fixtureshttp.MyStruct
	if rf, ok := ret.Get(0).(func(string) fixtureshttp.MyStruct); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(fixtureshttp.MyStruct)
	}

	return r0
}

type ExampleBExpectation struct {
	call *mock.Call
}

func (_e *ExampleExpectation) B(_a0 string) *ExampleBExpectation {
	return &ExampleBExpectation{
		call: _e.mock.On("B", _a0),
	}
}

func (_e *ExampleBExpectation) ToReturn(_a0 fixtureshttp.MyStruct) *mock.Call {
	return _e.call.Return(_a0)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "same_name_imports.go"), "Example", false,
		expected,
	)
}

func (s *GeneratorSuite) TestGeneratorWithImportSameAsLocalPackageInpkgNoCycle() {
	iface := s.getInterfaceFromFile("imports_same_as_package.go", "ImportsSameAsPackage")
	pkg := iface.QualifiedName
	gen := NewGenerator(iface, pkg, true)
	gen.GeneratePrologue(pkg)
	s.NotContains(gen.buf.String(), `import test "github.com/namely/mockery/mockery/fixtures/test"`)
}

func (s *GeneratorSuite) TestGeneratorWithImportSameAsLocalPackage() {
	expected := `// ImportsSameAsPackage is an autogenerated mock type for the ImportsSameAsPackage type
type ImportsSameAsPackage struct {
	mock.Mock
}

type ImportsSameAsPackageExpectation struct {
	mock *mock.Mock
}

func (_m *ImportsSameAsPackage) Expect() *ImportsSameAsPackageExpectation {
	return &ImportsSameAsPackageExpectation{mock: &_m.Mock}
}

// A provides a mock function with given fields:
func (_m *ImportsSameAsPackage) A() test.B {
	ret := _m.Called()

	var r0 test.B
	if rf, ok := ret.Get(0).(func() test.B); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(test.B)
	}

	return r0
}

type ImportsSameAsPackageAExpectation struct {
	call *mock.Call
}

func (_e *ImportsSameAsPackageExpectation) A() *ImportsSameAsPackageAExpectation {
	return &ImportsSameAsPackageAExpectation{
		call: _e.mock.On("A"),
	}
}

func (_e *ImportsSameAsPackageAExpectation) ToReturn(_a0 test.B) *mock.Call {
	return _e.call.Return(_a0)
}

// B provides a mock function with given fields:
func (_m *ImportsSameAsPackage) B() fixtures.KeyManager {
	ret := _m.Called()

	var r0 fixtures.KeyManager
	if rf, ok := ret.Get(0).(func() fixtures.KeyManager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fixtures.KeyManager)
		}
	}

	return r0
}

type ImportsSameAsPackageBExpectation struct {
	call *mock.Call
}

func (_e *ImportsSameAsPackageExpectation) B() *ImportsSameAsPackageBExpectation {
	return &ImportsSameAsPackageBExpectation{
		call: _e.mock.On("B"),
	}
}

func (_e *ImportsSameAsPackageBExpectation) ToReturn(_a0 fixtures.KeyManager) *mock.Call {
	return _e.call.Return(_a0)
}

// C provides a mock function with given fields: _a0
func (_m *ImportsSameAsPackage) C(_a0 fixtures.C) {
	_m.Called(_a0)
}

type ImportsSameAsPackageCExpectation struct {
	call *mock.Call
}

func (_e *ImportsSameAsPackageExpectation) C(_a0 fixtures.C) *ImportsSameAsPackageCExpectation {
	return &ImportsSameAsPackageCExpectation{
		call: _e.mock.On("C", _a0),
	}
}

func (_e *ImportsSameAsPackageCExpectation) ToReturn() *mock.Call {
	return _e.call.Return()
}
`
	s.checkGeneration(
		"imports_same_as_package.go", "ImportsSameAsPackage", false,
		expected,
	)
}

func (s *GeneratorSuite) TestPrologueWithImportSameAsLocalPackage() {
	generator := s.getGenerator(
		"imports_same_as_package.go", "ImportsSameAsPackage", false,
	)
	expected := `package mocks

import fixtures "` + generator.iface.QualifiedName + `"
import mock "github.com/stretchr/testify/mock"
import test "github.com/namely/mockery/mockery/fixtures/test"

`
	s.checkPrologueGeneration(generator, expected)
}

func (s *GeneratorSuite) TestPrologueWithImportFromNestedInterface() {
	generator := s.getGenerator(
		"imports_from_nested_interface.go", "HasConflictingNestedImports", false,
	)
	expected := `package mocks

import fixtureshttp "github.com/namely/mockery/mockery/fixtures/http"
import http "net/http"
import mock "github.com/stretchr/testify/mock"
import test "github.com/namely/mockery/mockery/fixtures"

`

	s.checkPrologueGeneration(generator, expected)
}

func (s *GeneratorSuite) TestGeneratorForStructValueReturn() {
	expected := `// A is an autogenerated mock type for the A type
type A struct {
	mock.Mock
}

type AExpectation struct {
	mock *mock.Mock
}

func (_m *A) Expect() *AExpectation {
	return &AExpectation{mock: &_m.Mock}
}

// Call provides a mock function with given fields:
func (_m *A) Call() (test.B, error) {
	ret := _m.Called()

	var r0 test.B
	if rf, ok := ret.Get(0).(func() test.B); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(test.B)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ACallExpectation struct {
	call *mock.Call
}

func (_e *AExpectation) Call() *ACallExpectation {
	return &ACallExpectation{
		call: _e.mock.On("Call"),
	}
}

func (_e *ACallExpectation) ToReturn(_a0 test.B, _a1 error) *mock.Call {
	return _e.call.Return(_a0, _a1)
}
`
	s.checkGeneration(
		filepath.Join(fixturePath, "struct_value.go"), "A", false,
		expected,
	)
}

func TestGeneratorSuite(t *testing.T) {
	generatorSuite := new(GeneratorSuite)
	suite.Run(t, generatorSuite)
}
